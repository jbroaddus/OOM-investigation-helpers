## @brief Generates visuals and video using session files generated by buddy-recorder

import argparse
import cv2 as cv
import matplotlib.pyplot as plt
import os
import yaml

VISUAL_DIR_SUFFIX = "visuals/"
VIDEO_DIR_SUFFIX = "video/"

class BarPlot:
    def __init__(self, x_items, y_items, x_label, y_label, title, dest_file_path):
        self.x_items = x_items
        self.y_items = y_items
        self.x_label = x_label
        self.y_label = y_label
        self.title = title
        self.dest_file_path = dest_file_path

    def generateAndSave(self, y_max):
        plt.bar(self.x_items, self.y_items)
        plt.xlabel(self.x_label)
        plt.ylabel(self.y_label)
        plt.ylim(0, y_max)
        plt.title(self.title)
        plt.savefig(self.dest_file_path)
        plt.close()

def main():

    # Parse for session file path

    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--session_path", help="Path to session file to generate visuals for")
    parser.add_argument("-m", "--minimum_order", help="Minimum order (inclusive) to generate visuals with", nargs='?', default=0, type=int)
    parser.add_argument("-v", "--video", help="Generates a video from session plot", action='store_true')
    parser.add_argument("-f", "--fps", help="FPS of the generated video", nargs='?', default=1, type=int)

    args = parser.parse_args()

    assert args.session_path, "Path to session file MUST be provided to generate visuals, use --help for more info"

    session_file_path = args.session_path

    # Check if path provided is indeed a valid path on the file system

    assert os.path.exists(session_file_path), "Invalid session file path provided - " + session_file_path

    # Parse the session file with a YAML library

    session_dic = {}

    with open(session_file_path) as stream:
        session_dic = yaml.safe_load(stream)

    # Create the destination directories

    visuals_directory_path = os.path.dirname(session_file_path) + '/' + VISUAL_DIR_SUFFIX
    video_directory_path = os.path.dirname(session_file_path) + '/' + VIDEO_DIR_SUFFIX

    if not os.path.exists(visuals_directory_path):
        os.mkdir(visuals_directory_path)

    # Iterate over the entries in the recorded sequence to generate plots with max scale

    bar_plot_list = []
    y_max = 0

    for entry in session_dic["sequence"]:

        # Extract values from keys
        epoch_time_stamp_s = entry["time_stamp"]
        formatted_time_str = entry["formatted_time"]
        event_str = entry["event"]
        order_quantity_dic = entry["order_quantities"]

        # Filter order quantities dictionary for the the minimum order specified by the CLI arg

        max_order = max(order_quantity_dic.keys())

        assert max_order > args.minimum_order, f"Minimum order specified ({args.minimum_order}) is larger than the max order provided by the session file ({max_order})"

        filtered_min_order_quantity_dic = {key: value for key, value in order_quantity_dic.items() if key >= args.minimum_order}

        order_list = [str(key) for key in filtered_min_order_quantity_dic.keys()]
        quantities_list = list(filtered_min_order_quantity_dic.values())

        # Find the max quantity to set the y limit in the plot

        if max(quantities_list) > y_max:
            y_max = max(quantities_list)

        # Append a BarPlot obj to the bar plot list to be generated and saved to file later

        bar_plot_list.append(BarPlot(order_list, quantities_list, 'Memory Orders', 'Quantities', formatted_time_str + '\n' + event_str, visuals_directory_path + str(epoch_time_stamp_s) + 'png'))

    # Generate and save bar plots

    print("Saving visuals to " + visuals_directory_path)

    for plot in bar_plot_list:
        plot.generateAndSave(y_max)

    # If the video option has been specified, generate a video using opencv

    if args.video == True:

        # Get the file names

        visual_file_names = [img for img in os.listdir(visuals_directory_path) if img.endswith(".png")]
        visual_file_names.sort()

        # Extract the frame info

        frame = cv.imread(os.path.join(visuals_directory_path, visual_file_names[0]))
        height, width, layers = frame.shape

        # Create the destination directory (if it does not exist)

        if not os.path.exists(video_directory_path):
            os.mkdir(video_directory_path)

        # Create the video writer

        video = cv.VideoWriter(video_directory_path + str(epoch_time_stamp_s) + '.avi', cv.VideoWriter_fourcc(*'XVID'), args.fps, (width, height))

        # Iterate over the visuals

        for visual_file_name in visual_file_names:

            # Read in visual from image file and write to the video writer

            img = cv.imread(visuals_directory_path + visual_file_name)
            video.write(img)

        # Release the video writer (saves video to destination)

        print("Saving video to " + video_directory_path + str(epoch_time_stamp_s) + '.avi')
        video.release()

if __name__ == "__main__":
    main()
